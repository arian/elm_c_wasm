/**
 * App-specific values generated by the Elm compiler
 * to facilitate JS/Wasm interaction
 *
 * Record Fields
 *  Mapping known at compile time
 *  Already have a way to get unique IDs (reuse --optimize code)
 *
 * Record FieldGroups
 *  Mapping NOT known at compile time (memory addresses)
 *  It needs both code generation and initialisation.
 *  Generate a C array of addresses, and an exported function to read it out sequentially
 *  Generate a JS array of concatenated names in the same order
 *  On init, build the fieldGroups map
 *
 * Custom type constructors
 *  Mapping known at compile time
 *  js->wasm
 *    It's possible for JS to have name clashes
 *    Need a compiler mod
 *  wasm->js
 *    Need to generate unique IDs for all ctors (Haskell Set or Map)
 */
interface NameToInt {
  [name: string]: number;
}
interface IntToName {
  [int: number]: string;
}

declare const fieldGroupNames: string[];

declare const appTypes: {
  fields: NameToInt & IntToName;
  fieldGroups: NameToInt & IntToName; // generated as empty {}, filled on app init
  ctors: NameToInt & IntToName;
};
